This is the API to the PHISH library that minnows (stand-alone
applications) call.  This is a C-style API, so it is easy to write
minnows in any language, e.g. C, C++, Fortran, Python, that call
the PHISH library.

Decide where to doc the Python interface (in each doc page)?
Is the Sockets interface identical?

PHISH minnows send and receive datums by communicating with
other minnows.  Before looking at the specific library
calls for sending and receiving datums, its helpful to
understand how the data in a datum is structured by the
PHISH library.

This is discussed below, in the sub-section "What is a datum?"_#what.

The PHISH library is not large; there are only a handful of calls.
They can be grouped into the following 5 categories.  Follow the links
to see a doc page for each library call.  A general discussion of how
minnows call these functions is given in the "Minnows"_Minnows.html
section of the manual.

Library calls for initialization :olb,l
  "phish_init()"_phish_init.html :ulb,b
  "phish_init_python()"_phish_init.html :b
  "phish_input()"_phish_callback.html :b
  "phish_output()"_phish_callback.html :b
  "phish_done()"_phish_callback.html :b
  "phish_check()"_phish_check.html :ule,b

Library calls for shutdown :l
  "phish_exit()"_phish_exit.html :ulb,b
  "phish_close()"_phish_close.html :ule,b

Library calls for receiving datums :l
  "phish_loop()"_phish_loop.html :ulb,b
  "phish_probe()"_phish_probe.html :b
  "phish_recv()"_phish_recv.html :b
  "phish_unpack()"_phish_unpack.html :b
  "phish_datum()"_phish_datum.html :ule,b

Library calls for sending datums :l
  "phish_send()"_phish_send.html :ulb,b
  "phish_send_key()"_phish_send_key.html :b
  "phish_send_direct()"_phish_send_direct.html :b
  "phish_pack_datum()"_phish_pack_datum.html :b
  "phish_pack_raw()"_phish_pack_raw.html :b
  "phish_pack_byte()"_phish_pack_byte.html :b
  "phish_pack_int()"_phish_pack_int.html :b
  "phish_pack_uint64()"_phish_pack_uint64.html :b
  "phish_pack_double()"_phish_pack_double.html :b
  "phish_pack_string()"_phish_pack_string.html :b
  "phish_pack_int_array()"_phish_pack_int_array.html :b
  "phish_pack_uint64_array()"_phish_pack_uint64_array.html :b
  "phish_pack_double_array()"_phish_pack_double_array.html :ule,b

Miscellaneous library calls :l
  "phish_world()"_phish_init.html :ulb,b
  "phish_reset_receiver()"_phish_reset_receiver.html :b
  "phish_error()"_phish_error.html :b
  "phish_warn()"_phish_error.html :b
  "phish_timer()"_phish_timer.html :ule,b
:ole

Discuss limits and options affecting library:

make MAXBUF and PHISH_SAFE_SEND be settable options by user?

:line
:line

What is a datum? :h4

A datum is a chunk of bytes sent from one PHISH minnow to another.
This section describes the format of the chunk, which is the same whether
the datum is sent via MPI or via sockets.

# of fields in datum (int)
type of 1st field (int)
size of 1st field (optional int)
data for 1st field (bytes)
type of 2nd field (int)
size of 2nd field (optional int)
data for 2nd field (bytes)
...
type of Nth field (int)
size of Nth field (optional int)
data for Nth field (bytes) :ul

The "type" values are one of these settings, as defined in src/phish.h:

#define PHISH_RAW 0
#define PHISH_BYTE 1
#define PHISH_INT 2
#define PHISH_UINT64 3
#define PHISH_DOUBLE 4
#define PHISH_STRING 5
#define PHISH_INT_ARRAY 6
#define PHISH_UINT64_ARRAY 7
#define PHISH_DOUBLE_ARRAY 8 :ul

PHISH_RAW is a list of raw bytes, which can be of any length, and
which the user can format in any manner.  PHISH_BYTE is a single byte.
PHISH_STRING is a NULL-terminated C-style string.  The NULL is
included in the datum.  The ARRAYS are contiguous lists of int, uint64
or double values.

The "size" values are only included for PHISH_RAW (# of bytes),
PHISH_STRING (# of bytes including NULL), and the ARRAY types (# of
values).

The field data is packed into the datum in a contiguous manner.

NOTE: what about alignment with mix of int/double, or when
single PHISH_BYTE are packed?

The maximum allowed size of a datum (in bytes) is set by MAXBUF in
src/phish.cpp, which defaults to 1 Mbyte.

Additionally, MPI flags the messages with a "tag".  This tag encodes
the receiver's port and also a "done" flag.  If it is not a done
message, the tag is the receiver's port (0 to Nport-1).  For a done
message a value of MAXPORT (defined at the top of src/phish.cpp) is
added to the tag.

How is this encoding of port and done implemented for sockets?

MPI also allows the receiver to query the byte size of the message,
which is used for the "full" pack/unpack calls below.

